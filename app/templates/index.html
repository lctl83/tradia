<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IA DCI - Assistants linguistiques</title>
    <link rel="icon" type="image/jpeg" href="/static/logo-dci.jpg">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #f5f7fb 0%, #e9ecf5 100%);
            min-height: 100vh;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 24px 48px rgba(15, 23, 42, 0.18);
            max-width: 1400px;
            width: 100%;
            padding: 40px 50px;
            margin: 20px auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #f0f0f0;
        }

        .logo {
            max-width: 180px;
            height: auto;
            margin-bottom: 20px;
        }

        h1 {
            color: #424242;
            margin-bottom: 10px;
            font-size: 30px;
            font-weight: 600;
        }

        .subtitle {
            color: #555;
            margin-bottom: 0;
            font-size: 16px;
        }

        .data-notice {
            margin-top: 12px;
            color: #607D8B;
            font-size: 13px;
        }

        .form-group {
            margin-bottom: 24px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #424242;
            font-weight: 600;
            font-size: 14px;
        }

        select,
        textarea {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 15px;
            transition: all 0.3s;
            background: white;
            resize: vertical;
        }

        textarea[readonly] {
            background: #f9fafc;
            cursor: default;
        }

        .rtl-support {
            direction: rtl;
            text-align: right;
        }

        select:focus,
        textarea:focus {
            outline: none;
            border-color: #1976D2;
            box-shadow: 0 0 0 3px rgba(25, 118, 210, 0.1);
        }

        .tabs {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
            border-bottom: 2px solid #f0f0f0;
            padding-bottom: 12px;
            flex-wrap: wrap;
        }

        .tab-button {
            flex: 1;
            min-width: 180px;
            padding: 12px;
            border: none;
            border-radius: 8px;
            background: #f5f5f5;
            cursor: pointer;
            font-weight: 600;
            color: #424242;
            transition: all 0.3s;
        }

        .tab-button.active {
            background: #e8f0fe;
            color: #1d4ed8;
            box-shadow: 0 6px 16px rgba(37, 99, 235, 0.18);
        }

        .tab-content {
            display: none;
            animation: fade-in 0.3s ease;
        }

        .tab-content.active {
            display: block;
        }

        .dual-panel {
            display: flex;
            gap: 20px;
            align-items: stretch;
            margin-bottom: 20px;
        }

        .panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .panel textarea {
            min-height: 350px;
            flex: 1;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .copy-btn {
            background: none;
            border: none;
            color: #1976D2;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .copy-btn:hover {
            text-decoration: underline;
        }

        .btn {
            width: 100%;
            padding: 16px;
            background: linear-gradient(135deg, #2563EB 0%, #1D4ED8 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.25);
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 12px 24px rgba(29, 78, 216, 0.35);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .progress {
            margin-top: 20px;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #2563EB, #1D4ED8);
            transition: width 0.3s;
            animation: progress-animation 2s ease-in-out infinite;
        }

        @keyframes progress-animation {
            0% {
                transform: translateX(-100%);
            }

            100% {
                transform: translateX(400%);
            }
        }

        .progress-text {
            text-align: center;
            margin-top: 8px;
            font-size: 14px;
            color: #757575;
        }

        .error {
            margin-top: 20px;
            padding: 16px;
            background: #FFEBEE;
            border-left: 4px solid #E85D3F;
            border-radius: 4px;
            display: none;
        }

        .error-text {
            color: #C62828;
            font-size: 14px;
        }

        .explanations {
            background: #f5f5f5;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 20px;
            display: none;
        }

        /* Styles pour le surlignage des corrections */
        .diff-output {
            width: 100%;
            min-height: 350px;
            padding: 12px 16px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 15px;
            background: #f9fafc;
            line-height: 1.6;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-y: auto;
            flex: 1;
        }

        .diff-deleted {
            background-color: #fee2e2;
            color: #b91c1c;
            text-decoration: line-through;
            padding: 1px 3px;
            border-radius: 3px;
            margin-right: 2px;
        }

        .diff-added {
            background-color: #dcfce7;
            color: #15803d;
            font-weight: 600;
            padding: 1px 3px;
            border-radius: 3px;
        }

        .explanations h3 {
            font-size: 16px;
            color: #374151;
            margin-bottom: 12px;
        }

        .explanations ul {
            list-style: disc;
            padding-left: 20px;
            color: #424242;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .summary-sections {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 20px;
        }

        .summary-section {
            background: #f5f5f5;
            border-radius: 8px;
            padding: 16px;
        }

        .summary-section h4 {
            font-size: 15px;
            color: #1d4ed8;
            margin-bottom: 10px;
        }

        .summary-section ul {
            list-style: disc;
            padding-left: 18px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            color: #424242;
        }

        @keyframes fade-in {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .language-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-bottom: 24px;
        }

        @media (max-width: 900px) {
            .dual-panel {
                flex-direction: column;
            }

            .panel textarea {
                min-height: 200px;
            }
        }

        @media (max-width: 600px) {
            .container {
                padding: 24px;
            }

            .language-grid {
                grid-template-columns: 1fr;
            }

            .tabs {
                flex-direction: column;
            }

            h1 {
                font-size: 26px;
            }
        }

        /* Image upload zone */
        .image-upload-zone {
            border: 2px dashed #cbd5e1;
            border-radius: 8px;
            padding: 24px;
            text-align: center;
            background: #f8fafc;
            transition: all 0.3s ease;
            cursor: pointer;
            margin-bottom: 16px;
        }

        .image-upload-zone:hover,
        .image-upload-zone.drag-over {
            border-color: #2563eb;
            background: #eff6ff;
        }

        .image-upload-zone.has-image {
            border-style: solid;
            border-color: #22c55e;
            background: #f0fdf4;
        }

        .image-upload-icon {
            font-size: 32px;
            margin-bottom: 8px;
        }

        .image-upload-text {
            color: #64748b;
            font-size: 14px;
        }

        .image-upload-text strong {
            color: #2563eb;
        }

        .image-preview-container {
            display: none;
            position: relative;
            margin-top: 12px;
        }

        .image-preview-container.visible {
            display: block;
        }

        .image-preview {
            max-width: 100%;
            max-height: 200px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .image-clear-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: #ef4444;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s;
        }

        .image-clear-btn:hover {
            transform: scale(1.1);
        }

        .upload-or-text {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
            color: #94a3b8;
            font-size: 13px;
        }

        .upload-or-text::before,
        .upload-or-text::after {
            content: '';
            flex: 1;
            height: 1px;
            background: #e2e8f0;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <img src="/static/logo-dci.jpg" alt="Logo DCI" class="logo">
            <p class="subtitle" id="headerSubtitle">Traduisez, reformulez et corrigez vos textes avec une IA interne DCI
            </p>
            <p class="data-notice">üîí Aucune donn√©e n'est envoy√©e √† l'ext√©rieur ou conserv√©e sur ce serveur.</p>
        </div>

        <form id="assistantForm">
            <div class="language-grid" id="languageSelectors">
                <div class="form-group">
                    <label for="source_lang">Langue source</label>
                    <select id="source_lang" name="source_lang" required>
                        {% for code, name in languages.items() %}
                        <option value="{{ code }}">{{ name }}</option>
                        {% endfor %}
                    </select>
                </div>

                <div class="form-group">
                    <label for="target_lang">Langue cible</label>
                    <select id="target_lang" name="target_lang" required>
                        {% for code, name in languages.items() %}
                        <option value="{{ code }}" {% if code=='en' %}selected{% endif %}>{{ name }}</option>
                        {% endfor %}
                    </select>
                </div>
            </div>

            <div class="form-group">
                <label for="model">Mod√®le Ollama</label>
                <select id="model" name="model">
                    <option value="{{ default_model }}">{{ default_model }}</option>
                </select>
            </div>

            <div class="tabs" role="tablist">
                <button type="button" class="tab-button active" data-tab="translation" aria-selected="true">üìù
                    Traduction</button>
                <button type="button" class="tab-button" data-tab="correction" aria-selected="false">‚úÖ Correction
                    orthographique</button>
                <button type="button" class="tab-button" data-tab="reformulation" aria-selected="false">‚ôªÔ∏è
                    Reformulation</button>
                <button type="button" class="tab-button" data-tab="summary" aria-selected="false">üóÇÔ∏è Compte
                    rendu</button>
            </div>

            <div id="translationTab" class="tab-content active" role="tabpanel">
                <div class="dual-panel">
                    <div class="panel">
                        <label for="textInput">Texte √† traduire</label>
                        <textarea id="textInput" name="text" rows="10"
                            placeholder="Entrez le texte √† traduire..."></textarea>
                    </div>
                    <div class="panel">
                        <div class="panel-header">
                            <label for="translatedTextOutput">R√©sultat</label>
                            <button type="button" class="copy-btn" id="copyTranslationBtn">üìã Copier</button>
                        </div>
                        <textarea id="translatedTextOutput" rows="10" readonly></textarea>
                    </div>
                </div>
                <button type="submit" class="btn" id="translateSubmitBtn">‚ö° Traduire</button>
            </div>

            <div id="correctionTab" class="tab-content" role="tabpanel">
                <div class="dual-panel">
                    <div class="panel">
                        <label for="correctionInput">Texte √† corriger</label>
                        <textarea id="correctionInput" rows="10"
                            placeholder="Collez votre texte √† corriger..."></textarea>
                    </div>
                    <div class="panel">
                        <div class="panel-header">
                            <label>Texte corrig√© (diff√©rences surlign√©es)</label>
                            <button type="button" class="copy-btn" id="copyCorrectionBtn">üìã Copier</button>
                        </div>
                        <div id="correctionDiff" class="diff-output"></div>
                        <textarea id="correctionOutput" style="display:none;"></textarea>
                    </div>
                </div>
                <div class="explanations" id="correctionExplanations">
                    <h3>Explications des corrections</h3>
                    <ul id="correctionExplanationList"></ul>
                </div>
                <button type="submit" class="btn" id="correctionSubmitBtn">‚úÖ Corriger</button>
            </div>

            <div id="reformulationTab" class="tab-content" role="tabpanel">
                <div class="dual-panel">
                    <div class="panel">
                        <label for="reformulationInput">Texte √† reformuler</label>
                        <textarea id="reformulationInput" rows="10"
                            placeholder="Collez votre texte √† reformuler..."></textarea>
                    </div>
                    <div class="panel">
                        <div class="panel-header">
                            <label for="reformulationOutput">Texte reformul√©</label>
                            <button type="button" class="copy-btn" id="copyReformulationBtn">üìã Copier</button>
                        </div>
                        <textarea id="reformulationOutput" rows="10" readonly></textarea>
                    </div>
                </div>
                <div class="explanations" id="reformulationHighlights">
                    <h3>Mise en avant des modifications</h3>
                    <ul id="reformulationHighlightList"></ul>
                </div>
                <button type="submit" class="btn" id="reformulationSubmitBtn">‚ôªÔ∏è Reformuler</button>
            </div>

            <div id="summaryTab" class="tab-content" role="tabpanel">
                <div class="dual-panel">
                    <div class="panel">
                        <label for="summaryInput">Notes de r√©union</label>
                        <textarea id="summaryInput" rows="8" placeholder="Collez vos notes de r√©union..."></textarea>

                        <div class="upload-or-text">ou importez une photo</div>

                        <div class="image-upload-zone" id="imageUploadZone">
                            <div class="image-upload-icon">üì∑</div>
                            <div class="image-upload-text">
                                <strong>Cliquez</strong> ou glissez-d√©posez une image<br>
                                <small>(photo de notes manuscrites, tableau blanc, etc.)</small>
                            </div>
                            <input type="file" id="summaryImageInput" accept="image/*" style="display: none;">
                            <div class="image-preview-container" id="imagePreviewContainer">
                                <img id="imagePreview" class="image-preview" alt="Pr√©visualisation">
                                <button type="button" class="image-clear-btn" id="imageClearBtn"
                                    title="Supprimer l'image">‚úï</button>
                            </div>
                        </div>
                    </div>
                    <div class="panel">
                        <div class="panel-header">
                            <label for="summaryOutput">Compte rendu g√©n√©r√©</label>
                            <button type="button" class="copy-btn" id="copySummaryBtn">üìã Copier</button>
                        </div>
                        <textarea id="summaryOutput" rows="10" readonly></textarea>
                    </div>
                </div>
                <div class="summary-sections">
                    <div class="summary-section">
                        <h4>D√©cisions</h4>
                        <ul id="summaryDecisions"></ul>
                    </div>
                    <div class="summary-section">
                        <h4>Actions √† mener</h4>
                        <ul id="summaryActions"></ul>
                    </div>
                </div>
                <button type="submit" class="btn" id="summarySubmitBtn">üóÇÔ∏è G√©n√©rer le compte rendu</button>
            </div>
        </form>

        <div class="progress" id="progress">
            <div class="progress-bar">
                <div class="progress-bar-fill"></div>
            </div>
            <div class="progress-text" id="progressText">Traitement en cours...</div>
        </div>

        <div class="error" id="error">
            <div class="error-text" id="errorText"></div>
        </div>
    </div>

    <script>
        const rtlLanguages = {{ rtl_languages| tojson }};
        const fallbackModel = "{{ default_model }}";
        let activeTab = 'translation';

        const form = document.getElementById('assistantForm');
        const sourceLang = document.getElementById('source_lang');
        const targetLang = document.getElementById('target_lang');
        const modelSelect = document.getElementById('model');
        const languageSelectors = document.getElementById('languageSelectors');

        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = {
            translation: document.getElementById('translationTab'),
            correction: document.getElementById('correctionTab'),
            reformulation: document.getElementById('reformulationTab'),
            summary: document.getElementById('summaryTab'),
        };

        const translationInput = document.getElementById('textInput');
        const translationOutput = document.getElementById('translatedTextOutput');
        const copyTranslationBtn = document.getElementById('copyTranslationBtn');

        const correctionInput = document.getElementById('correctionInput');
        const correctionOutput = document.getElementById('correctionOutput');
        const correctionDiff = document.getElementById('correctionDiff');
        const correctionExplanations = document.getElementById('correctionExplanations');
        const correctionExplanationList = document.getElementById('correctionExplanationList');
        const copyCorrectionBtn = document.getElementById('copyCorrectionBtn');

        const reformulationInput = document.getElementById('reformulationInput');
        const reformulationOutput = document.getElementById('reformulationOutput');
        const reformulationHighlights = document.getElementById('reformulationHighlights');
        const reformulationHighlightList = document.getElementById('reformulationHighlightList');
        const copyReformulationBtn = document.getElementById('copyReformulationBtn');

        const summaryInput = document.getElementById('summaryInput');
        const summaryOutput = document.getElementById('summaryOutput');
        const summaryDecisions = document.getElementById('summaryDecisions');
        const summaryActions = document.getElementById('summaryActions');
        const copySummaryBtn = document.getElementById('copySummaryBtn');

        // Image upload elements
        const imageUploadZone = document.getElementById('imageUploadZone');
        const summaryImageInput = document.getElementById('summaryImageInput');
        const imagePreviewContainer = document.getElementById('imagePreviewContainer');
        const imagePreview = document.getElementById('imagePreview');
        const imageClearBtn = document.getElementById('imageClearBtn');
        let summaryImageBase64 = null;

        const rtlLanguageSet = new Set(Array.isArray(rtlLanguages) ? rtlLanguages : []);

        const submitButtons = {
            translation: document.getElementById('translateSubmitBtn'),
            correction: document.getElementById('correctionSubmitBtn'),
            reformulation: document.getElementById('reformulationSubmitBtn'),
            summary: document.getElementById('summarySubmitBtn'),
        };

        const progress = document.getElementById('progress');
        const progressText = document.getElementById('progressText');
        const errorDiv = document.getElementById('error');
        const errorText = document.getElementById('errorText');

        const progressMessages = {
            translation: 'Traduction en cours...',
            correction: 'Correction en cours...',
            reformulation: 'Reformulation en cours...',
            summary: 'G√©n√©ration du compte rendu...',
        };

        const streamingMessages = {
            translation: 'L\'IA g√©n√®re la traduction...',
            correction: 'L\'IA corrige le texte...',
            reformulation: 'L\'IA reformule le texte...',
            summary: 'L\'IA g√©n√®re le compte rendu...',
        };

        // ============================================================================
        // STREAMING HELPER - Affichage progressif des r√©ponses
        // ============================================================================

        /**
         * Effectue une requ√™te streaming et affiche les tokens progressivement.
         * @param {string} url - URL de l'endpoint streaming
         * @param {FormData} formData - Donn√©es du formulaire
         * @param {HTMLElement} outputElement - √âl√©ment o√π afficher les tokens (textarea ou div)
         * @param {Function} onComplete - Callback appel√© √† la fin avec le texte complet
         * @returns {Promise<string>} - Le texte complet g√©n√©r√©
         */
        async function streamRequest(url, formData, outputElement, onComplete) {
            const response = await fetch(url, {
                method: 'POST',
                body: formData,
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.detail || 'Erreur de streaming');
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let fullText = '';

            // R√©initialiser l'output
            if (outputElement.tagName === 'TEXTAREA') {
                outputElement.value = '';
            } else {
                outputElement.textContent = '';
            }

            try {
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value, { stream: true });
                    const lines = chunk.split('\n');

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = line.slice(6).trim();

                            if (data === '[DONE]') {
                                if (onComplete) {
                                    onComplete(fullText);
                                }
                                return fullText;
                            }

                            try {
                                const parsed = JSON.parse(data);
                                if (parsed.error) {
                                    throw new Error(parsed.error);
                                }
                                if (parsed.token) {
                                    fullText += parsed.token;
                                    // Mise √† jour progressive de l'affichage
                                    if (outputElement.tagName === 'TEXTAREA') {
                                        outputElement.value = fullText;
                                        // Auto-scroll vers le bas
                                        outputElement.scrollTop = outputElement.scrollHeight;
                                    } else {
                                        outputElement.textContent = fullText;
                                        outputElement.scrollTop = outputElement.scrollHeight;
                                    }
                                }
                            } catch (e) {
                                if (e.message && !e.message.includes('JSON')) {
                                    throw e;
                                }
                                // Ignorer les erreurs de parsing JSON (lignes incompl√®tes)
                            }
                        }
                    }
                }
            } finally {
                reader.releaseLock();
            }

            if (onComplete) {
                onComplete(fullText);
            }
            return fullText;
        }

        tabButtons.forEach((button) => {
            button.addEventListener('click', () => {
                const tab = button.dataset.tab;
                if (tab === activeTab) {
                    return;
                }

                activeTab = tab;

                tabButtons.forEach((btn) => {
                    btn.classList.toggle('active', btn.dataset.tab === tab);
                    btn.setAttribute('aria-selected', btn.dataset.tab === tab ? 'true' : 'false');
                });

                Object.entries(tabContents).forEach(([key, content]) => {
                    content.classList.toggle('active', key === tab);
                });

                errorDiv.style.display = 'none';
                progress.style.display = 'none';

                const requiresLanguages = tab === 'translation';
                languageSelectors.style.display = requiresLanguages ? 'grid' : 'none';
            });
        });

        function renderList(container, items) {
            container.innerHTML = '';
            if (!items || !items.length) {
                return;
            }

            const fragment = document.createDocumentFragment();
            items.forEach((item) => {
                const li = document.createElement('li');
                // Handle both string items and object items (e.g., {change, impact})
                if (typeof item === 'string') {
                    li.textContent = item;
                } else if (typeof item === 'object' && item !== null) {
                    // Format object fields nicely
                    const parts = [];
                    if (item.change) parts.push(item.change);
                    if (item.impact) parts.push(`Impact: ${item.impact}`);
                    if (item.text) parts.push(item.text);
                    if (item.description) parts.push(item.description);
                    li.textContent = parts.length > 0 ? parts.join(' ‚Äî ') : JSON.stringify(item);
                } else {
                    li.textContent = String(item);
                }
                fragment.appendChild(li);
            });
            container.appendChild(fragment);
        }

        // Image upload handlers
        function handleImageFile(file) {
            if (!file || !file.type.startsWith('image/')) {
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                const base64Data = e.target.result;
                // Extract just the base64 part (remove data:image/...;base64, prefix)
                summaryImageBase64 = base64Data.split(',')[1];

                imagePreview.src = base64Data;
                imagePreviewContainer.classList.add('visible');
                imageUploadZone.classList.add('has-image');
            };
            reader.readAsDataURL(file);
        }

        function clearImage() {
            summaryImageBase64 = null;
            imagePreview.src = '';
            imagePreviewContainer.classList.remove('visible');
            imageUploadZone.classList.remove('has-image');
            summaryImageInput.value = '';
        }

        // Click to upload
        imageUploadZone.addEventListener('click', (e) => {
            if (e.target === imageClearBtn || e.target.closest('.image-clear-btn')) {
                return;
            }
            summaryImageInput.click();
        });

        // File input change
        summaryImageInput.addEventListener('change', (e) => {
            if (e.target.files && e.target.files[0]) {
                handleImageFile(e.target.files[0]);
            }
        });

        // Clear button
        imageClearBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            clearImage();
        });

        // Drag and drop
        imageUploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            imageUploadZone.classList.add('drag-over');
        });

        imageUploadZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            imageUploadZone.classList.remove('drag-over');
        });

        imageUploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            imageUploadZone.classList.remove('drag-over');
            if (e.dataTransfer.files && e.dataTransfer.files[0]) {
                handleImageFile(e.dataTransfer.files[0]);
            }
        });

        /**
         * G√©n√®re un HTML de diff entre le texte original et le texte corrig√©.
         * Utilise une approche mot par mot pour surligner les diff√©rences.
         */
        function generateDiffHtml(original, corrected) {
            // Tokeniser les textes en mots et espaces
            const tokenize = (text) => {
                const tokens = [];
                let current = '';
                for (const char of text) {
                    if (/\s/.test(char)) {
                        if (current) tokens.push({ type: 'word', value: current });
                        tokens.push({ type: 'space', value: char });
                        current = '';
                    } else {
                        current += char;
                    }
                }
                if (current) tokens.push({ type: 'word', value: current });
                return tokens;
            };

            const originalTokens = tokenize(original);
            const correctedTokens = tokenize(corrected);

            // Extraire uniquement les mots pour la comparaison LCS
            const origWords = originalTokens.filter(t => t.type === 'word').map(t => t.value);
            const corrWords = correctedTokens.filter(t => t.type === 'word').map(t => t.value);

            // Algorithme LCS (Longest Common Subsequence)
            const m = origWords.length;
            const n = corrWords.length;
            const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));

            for (let i = 1; i <= m; i++) {
                for (let j = 1; j <= n; j++) {
                    if (origWords[i - 1].toLowerCase() === corrWords[j - 1].toLowerCase()) {
                        dp[i][j] = dp[i - 1][j - 1] + 1;
                    } else {
                        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                    }
                }
            }

            // Backtrack pour trouver les diff√©rences
            const result = [];
            let i = m, j = n;
            const operations = [];

            while (i > 0 || j > 0) {
                if (i > 0 && j > 0 && origWords[i - 1].toLowerCase() === corrWords[j - 1].toLowerCase()) {
                    operations.unshift({ type: 'same', orig: origWords[i - 1], corr: corrWords[j - 1] });
                    i--; j--;
                } else if (j > 0 && (i === 0 || dp[i][j - 1] >= dp[i - 1][j])) {
                    operations.unshift({ type: 'add', corr: corrWords[j - 1] });
                    j--;
                } else {
                    operations.unshift({ type: 'del', orig: origWords[i - 1] });
                    i--;
                }
            }

            // G√©n√©rer le HTML
            let html = '';
            for (const op of operations) {
                if (op.type === 'same') {
                    html += `<span>${escapeHtml(op.corr)}</span> `;
                } else if (op.type === 'del') {
                    html += `<span class="diff-deleted">${escapeHtml(op.orig)}</span> `;
                } else if (op.type === 'add') {
                    html += `<span class="diff-added">${escapeHtml(op.corr)}</span> `;
                }
            }

            return html.trim();
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function updateLanguageDirection() {
            const sourceIsRTL = rtlLanguageSet.has(sourceLang.value);
            const targetIsRTL = rtlLanguageSet.has(targetLang.value);

            translationInput.dir = sourceIsRTL ? 'rtl' : 'ltr';
            translationInput.classList.toggle('rtl-support', sourceIsRTL);

            translationOutput.dir = targetIsRTL ? 'rtl' : 'ltr';
            translationOutput.classList.toggle('rtl-support', targetIsRTL);
        }

        function updateTargetLanguageOptions() {
            const selectedSource = sourceLang.value;
            const currentTarget = targetLang.value;

            // Masquer/afficher les options selon la langue source
            Array.from(targetLang.options).forEach(option => {
                if (option.value === selectedSource) {
                    option.hidden = true;
                    option.disabled = true;
                } else {
                    option.hidden = false;
                    option.disabled = false;
                }
            });

            // Si la langue cible actuelle est la m√™me que la source, s√©lectionner une autre
            if (currentTarget === selectedSource) {
                const firstAvailable = Array.from(targetLang.options).find(
                    opt => opt.value !== selectedSource && !opt.hidden
                );
                if (firstAvailable) {
                    targetLang.value = firstAvailable.value;
                }
            }

            updateLanguageDirection();
        }

        function showCopyFeedback(button) {
            const original = button.textContent;
            button.textContent = '‚úÖ Copi√© !';
            setTimeout(() => {
                button.textContent = original;
            }, 1500);
        }

        async function copyToClipboard(text, button) {
            if (!text) {
                return;
            }
            try {
                await navigator.clipboard.writeText(text);
                showCopyFeedback(button);
            } catch (err) {
                console.warn('Impossible de copier le texte', err);
            }
        }

        copyTranslationBtn.addEventListener('click', () => copyToClipboard(translationOutput.value, copyTranslationBtn));
        copyCorrectionBtn.addEventListener('click', () => copyToClipboard(correctionOutput.value, copyCorrectionBtn));
        copyReformulationBtn.addEventListener('click', () => copyToClipboard(reformulationOutput.value, copyReformulationBtn));
        copySummaryBtn.addEventListener('click', () => copyToClipboard(summaryOutput.value, copySummaryBtn));

        sourceLang.addEventListener('change', updateTargetLanguageOptions);
        targetLang.addEventListener('change', updateLanguageDirection);
        updateTargetLanguageOptions(); // Initialiser au chargement

        /**
         * Parse une r√©ponse JSON potentiellement envelopp√©e dans du markdown.
         */
        function parseJsonResponse(rawText) {
            // Essayer d'extraire un bloc ```json ... ```
            const jsonBlockMatch = rawText.match(/```json\s*([\s\S]*?)\s*```/);
            if (jsonBlockMatch) {
                try {
                    return JSON.parse(jsonBlockMatch[1].trim());
                } catch (e) { }
            }

            // Essayer de trouver un objet JSON dans le texte
            const braceStart = rawText.indexOf('{');
            if (braceStart !== -1) {
                let depth = 0;
                let inString = false;
                let escapeNext = false;

                for (let i = braceStart; i < rawText.length; i++) {
                    const char = rawText[i];

                    if (escapeNext) {
                        escapeNext = false;
                        continue;
                    }
                    if (char === '\\') {
                        escapeNext = true;
                        continue;
                    }
                    if (char === '"') {
                        inString = !inString;
                    } else if (!inString) {
                        if (char === '{') depth++;
                        else if (char === '}') {
                            depth--;
                            if (depth === 0) {
                                try {
                                    return JSON.parse(rawText.slice(braceStart, i + 1));
                                } catch (e) { }
                                break;
                            }
                        }
                    }
                }
            }

            // Fallback: essayer de parser directement
            try {
                return JSON.parse(rawText.trim());
            } catch (e) {
                return null;
            }
        }

        form.addEventListener('submit', async (event) => {
            event.preventDefault();
            errorDiv.style.display = 'none';

            const activeButton = submitButtons[activeTab];
            if (!activeButton) {
                return;
            }

            activeButton.disabled = true;
            progressText.textContent = streamingMessages[activeTab] || progressMessages[activeTab] || 'Traitement en cours...';
            progress.style.display = 'block';

            try {
                const formData = new FormData();
                if (modelSelect.value) {
                    formData.append('model', modelSelect.value);
                }

                switch (activeTab) {
                    case 'translation': {
                        formData.append('text', translationInput.value);
                        formData.append('source_lang', sourceLang.value);
                        formData.append('target_lang', targetLang.value);

                        // Utiliser le streaming pour la traduction
                        await streamRequest(
                            '/translate-text-stream',
                            formData,
                            translationOutput
                        );
                        break;
                    }
                    case 'correction': {
                        formData.append('text', correctionInput.value);

                        // Streaming : afficher le JSON brut pendant la g√©n√©ration
                        // puis parser √† la fin pour extraire les donn√©es structur√©es
                        const rawResponse = await streamRequest(
                            '/correct-text-stream',
                            formData,
                            correctionOutput  // Affiche temporairement dans le textarea cach√©
                        );

                        // Parser le JSON une fois le streaming termin√©
                        const data = parseJsonResponse(rawResponse);
                        if (data) {
                            const correctedText = data.corrected_text || '';
                            correctionOutput.value = correctedText;

                            // G√©n√©rer et afficher le diff avec surlignage
                            const originalText = correctionInput.value;
                            correctionDiff.innerHTML = generateDiffHtml(originalText, correctedText);

                            renderList(correctionExplanationList, data.explanations || []);
                            correctionExplanations.style.display = (data.explanations && data.explanations.length) ? 'block' : 'none';
                        } else {
                            // Si le parsing √©choue, afficher le texte brut
                            correctionDiff.textContent = rawResponse;
                            correctionExplanations.style.display = 'none';
                        }
                        break;
                    }
                    case 'reformulation': {
                        formData.append('text', reformulationInput.value);

                        // Streaming avec parsing JSON √† la fin
                        const rawResponse = await streamRequest(
                            '/reformulate-text-stream',
                            formData,
                            reformulationOutput
                        );

                        const data = parseJsonResponse(rawResponse);
                        if (data) {
                            reformulationOutput.value = data.reformulated_text || rawResponse;
                            renderList(reformulationHighlightList, data.highlights || []);
                            reformulationHighlights.style.display = (data.highlights && data.highlights.length) ? 'block' : 'none';
                        } else {
                            reformulationHighlights.style.display = 'none';
                        }
                        break;
                    }
                    case 'summary': {
                        formData.append('text', summaryInput.value);

                        // Include image if uploaded
                        if (summaryImageBase64) {
                            formData.append('image_base64', summaryImageBase64);
                        }

                        // Streaming avec parsing JSON √† la fin
                        const rawResponse = await streamRequest(
                            '/meeting-summary-stream',
                            formData,
                            summaryOutput
                        );

                        const data = parseJsonResponse(rawResponse);
                        if (data) {
                            summaryOutput.value = data.summary || rawResponse;
                            renderList(summaryDecisions, data.decisions || []);
                            renderList(summaryActions, data.action_items || []);
                        }

                        // Clear image after successful processing
                        clearImage();
                        break;
                    }
                    default:
                        throw new Error('Onglet inconnu');
                }
            } catch (error) {
                showError(error.message);
            } finally {
                activeButton.disabled = false;
                progress.style.display = 'none';
            }
        });

        function showError(message) {
            errorText.textContent = message;
            errorDiv.style.display = 'block';
        }

        /**
         * Synchronise le d√©filement entre deux √©l√©ments scrollables.
         */
        function setupScrollSync(element1, element2) {
            let syncing = false;

            function sync(source, target) {
                if (syncing) return;
                syncing = true;
                const maxScroll = source.scrollHeight - source.clientHeight;
                const ratio = maxScroll > 0 ? source.scrollTop / maxScroll : 0;
                const targetMaxScroll = target.scrollHeight - target.clientHeight;
                target.scrollTop = ratio * targetMaxScroll;
                syncing = false;
            }

            element1.addEventListener('scroll', () => sync(element1, element2));
            element2.addEventListener('scroll', () => sync(element2, element1));
        }

        // Synchronisation pour la traduction
        setupScrollSync(translationInput, translationOutput);

        // Synchronisation pour la correction (textarea input et div diff)
        setupScrollSync(correctionInput, correctionDiff);

        async function loadModels() {
            // Descriptions des mod√®les pour aider l'utilisateur
            const modelDescriptions = {
                'ministral': '‚ö° Le plus rapide',
                'magistral': '‚ú® Le plus qualitatif mais plus lent',
            };

            function getModelLabel(modelName) {
                const lowerName = modelName.toLowerCase();
                for (const [key, desc] of Object.entries(modelDescriptions)) {
                    if (lowerName.includes(key)) {
                        return `${modelName} - ${desc}`;
                    }
                }
                return modelName;
            }

            try {
                const response = await fetch('/models');
                if (!response.ok) {
                    throw new Error('HTTP error');
                }

                const data = await response.json();
                const models = Array.isArray(data.models) ? data.models : [];
                const defaultModel = data.default_model || fallbackModel;

                let uniqueModels = Array.from(new Set(models.filter(Boolean)));
                uniqueModels.sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));

                if (defaultModel) {
                    uniqueModels = [defaultModel, ...uniqueModels.filter((modelName) => modelName !== defaultModel)];
                }

                if (!uniqueModels.length && defaultModel) {
                    uniqueModels = [defaultModel];
                }

                modelSelect.innerHTML = '';
                uniqueModels.forEach((modelName) => {
                    const option = document.createElement('option');
                    option.value = modelName;
                    option.textContent = getModelLabel(modelName);
                    if (modelName === defaultModel) {
                        option.selected = true;
                    }
                    modelSelect.appendChild(option);
                });
            } catch (error) {
                console.warn('Impossible de r√©cup√©rer la liste des mod√®les Ollama', error);
                if (!modelSelect.options.length) {
                    const option = document.createElement('option');
                    option.value = fallbackModel;
                    option.textContent = getModelLabel(fallbackModel);
                    modelSelect.appendChild(option);
                }
            }
        }

        loadModels();
    </script>
</body>

</html>